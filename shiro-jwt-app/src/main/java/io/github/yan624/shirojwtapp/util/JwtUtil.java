package io.github.yan624.shirojwtapp.util;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.DecodedJWT;

import java.io.UnsupportedEncodingException;


public class JwtUtil {
    public static final String AUDIENCE = "shiro-jwt-app";

    private static final String ISSUER = "simple-shiro-jwt-springboot";
    // 由 shiro-jwt-sso 生成 | generated by shiro-jwt-sso
    private static final String SECRET = "secret key";

    /**
     * https://datatracker.ietf.org/doc/html/rfc7519
     * @param token
     * @return
     */
    public static boolean verify(String token) throws UnsupportedEncodingException {
        final String aud = JwtUtil.decode(token).getClaim("aud").asString();
        if (AUDIENCE.equals(aud)){
            return false;
        }

        Algorithm algorithm = Algorithm.HMAC256(SECRET);
        JWTVerifier verifier = JWT.require(algorithm)
                .withIssuer(ISSUER)
                .build(); //Reusable verifier instance
        DecodedJWT jwt = verifier.verify(token);
        return true;
    }

    /**
     * 判断是否过期
     */
    public static boolean isExpire(String token) throws JWTDecodeException {
        DecodedJWT jwt = JWT.decode(token);
        return jwt.getExpiresAt().getTime() < System.currentTimeMillis() ;
    }

    public static DecodedJWT decode(String token){
        DecodedJWT jwt = JWT.decode(token);
        return jwt;
    }
}
